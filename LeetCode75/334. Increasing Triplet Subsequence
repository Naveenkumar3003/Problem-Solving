1Ô∏è‚É£ BRUTE FORCE (O(n¬≥)) ‚ùå
Idea
Check all possible triplets.

Code
bool increasingTriplet(vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                if (nums[i] < nums[j] && nums[j] < nums[k])
                    return true;
            }
        }
    }
    return false;
}

Problems
    Too slow for n = 10‚Åµ
    Time = O(n¬≥) ‚ùå

2Ô∏è‚É£ BETTER (Using prefix min & suffix max) ‚Äì O(n)

Idea
    For each middle element j:
      Find a smaller element on the left
      Find a bigger element on the right

Steps

    leftMin[i] = minimum from index 0 to i  
    rightMax[i] = maximum from index i to n-1
    
Check:
    leftMin[j-1] < nums[j] < rightMax[j+1]

Code
bool increasingTriplet(vector<int>& nums) {
    int n = nums.size();
    if (n < 3) return false;

    vector<int> leftMin(n), rightMax(n);

    leftMin[0] = nums[0];
    for (int i = 1; i < n; i++)
        leftMin[i] = min(leftMin[i - 1], nums[i]);

    rightMax[n - 1] = nums[n - 1];
    for (int i = n - 2; i >= 0; i--)
        rightMax[i] = max(rightMax[i + 1], nums[i]);

    for (int j = 1; j < n - 1; j++) {
        if (leftMin[j - 1] < nums[j] && nums[j] < rightMax[j + 1])
            return true;
    }

    return false;
}

Complexity
Time: O(n)
Space: O(n) ‚ùå (extra arrays)

3Ô∏è‚É£ OPTIMAL (Greedy, O(1) space) ‚úÖüî•
üîë Core Insight
We don‚Äôt need the actual triplet, only existence.

Track:
    first ‚Üí smallest number seen so far
    second ‚Üí smallest number greater than first
    
    If we find a number greater than both ‚Üí triplet exists

‚úÖ OPTIMAL CODE (Interview Favorite)
bool increasingTriplet(vector<int>& nums) {
    int first = INT_MAX;
    int second = INT_MAX;

    for (int num : nums) {
        if (num <= first)
            first = num;
        else if (num <= second)
            second = num;
        else
            return true; // num > first and num > second
    }

    return false;
}

| Approach             | Time     | Space      |
| -------------------- | -------- | ---------- |
| Brute Force          | O(n¬≥)    | O(1)       |
| Prefix/Suffix        | O(n)     | O(n)       |
| **Greedy (Optimal)** | **O(n)** | **O(1)** ‚úÖ |

