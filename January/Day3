1411. Number of Ways to Paint N Ã— 3 Grid
You have a grid of size n x 3 and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, 
or Green while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).
Given n the number of rows of the grid, return the number of ways you can paint this grid. As the answer may grow large, the answer must be computed modulo 1e9 + 7.

Constraints:
n == grid.length
1 <= n <= 5000

Input: n = 1
Output: 12
Explanation: There are 12 possible way to paint the grid as shown.

Input: n = 5000
Output: 30228214

Step1:
We have 3 colors:
ðŸ”´ Red (R), ðŸŸ¡ Yellow (Y), ðŸŸ¢ Green (G)

And 1 row with 3 columns.

ðŸ”¹ TYPE A â€“ All 3 colors are different

Pattern:

C1  C2  C3
(all different)

Step-by-step counting

For 1st cell â†’ choose any of 3 colors

For 2nd cell â†’ choose any of remaining 2 colors

For 3rd cell â†’ choose the last remaining color

ðŸ‘‰ Total ways:

3 Ã— 2 Ã— 1 = 6

Examples (all permutations of 3 colors):
R Y G
R G Y
Y R G
Y G R
G R Y
G Y R


âœ… So Type A = 6

ðŸ”¹ TYPE B â€“ First and third same, middle different

(no adjacent same)

Pattern:

C1  C2  C1


âš ï¸ Middle must be different from sides.

Step-by-step counting

Choose color for C1 & C3 â†’ 3 choices

Choose color for C2 â†’ must be different from C1
â†’ 2 choices

ðŸ‘‰ Total ways:

3 Ã— 2 = 6

Examples:
R Y R
R G R
Y R Y
Y G Y
G R G
G Y G


âœ… So Type B = 6

ðŸ§  Final Summary
Pattern Type	Formula	Ways
Type A (ABC)	3Ã—2Ã—1	6
Type B (ABA)	3Ã—2	6

Thatâ€™s why for row 1:

Type A = 6
Type B = 6
Total = 12


Step2:
What does â€œtransitionâ€ mean?

We already painted row i-1.
Now we want to paint row i such that:

âœ” No two adjacent horizontal cells in the same row are same
âœ” No two adjacent vertical cells (same column) are same

We only care about the pattern type of the previous row:

Type A â†’ all 3 colors different (ABC)

Type B â†’ first and third same (ABA)

ðŸŸ¦ Case 1: Previous Row = Type A (ABC)

Example previous row:

R  Y  G

âž¤ New Row as Type A (ABC)

New row also has 3 different colors.

Each column color must be different from the color above it.

Letâ€™s try all valid permutations and count.

From experience (or careful checking), only 2 permutations satisfy:

New row â‰  same color in same column


Example valid:

G R Y
Y G R


âŒ Other permutations violate at least one column.

âœ… Type A â†’ Type A = 2 ways

âž¤ New Row as Type B (ABA)

Pattern:

X  Y  X


Constraints:

X â‰  Y

X â‰  column1 above

Y â‰  column2 above

X â‰  column3 above

Try possibilities â†’ only 2 valid ways exist.

Example valid:

Y G Y
G R G


âœ… Type A â†’ Type B = 2 ways

ðŸŸ¨ Case 2: Previous Row = Type B (ABA)

Example:

R  Y  R

âž¤ New Row as Type A (ABC)

All 3 colors different.

Check permutations carefully â†’ only 2 permutations work that donâ€™t clash vertically.

Example:

Y R G
G R Y


âœ… Type B â†’ Type A = 2 ways

âž¤ New Row as Type B (ABA)

Pattern:

X  Y  X


Conditions:

X â‰  Y

X â‰  column1 above

Y â‰  column2 above

X â‰  column3 above

Here we get more flexibility than previous cases.

Careful counting gives 3 valid ways.

Example:

Y R Y
G R G
Y G Y


âœ… Type B â†’ Type B = 3 ways

ðŸ“Š Final Transition Table (PROVEN)
Previous	New A	New B
Type A	2	2
Type B	2	3
ðŸ§  Why this abstraction works

Instead of tracking exact colors, we track pattern types.
This reduces a huge problem into simple DP with 2 states.


Code:
Brute(Recursion):

class Solution {
public:
    static const int MOD = 1e9 + 7;

    long long fA(int n) {
        if (n == 1) return 6;
        return (2 * fA(n - 1) + 2 * fB(n - 1)) % MOD;
    }

    long long fB(int n) {
        if (n == 1) return 6;
        return (2 * fA(n - 1) + 3 * fB(n - 1)) % MOD;
    }

    int numOfWays(int n) {
        return (fA(n) + fB(n)) % MOD;
    }
};


Memoization:

class Solution{
public:
  static const int MOD = 1e9+7;
  long long dpA[5001];
  long long dpB[5001];

  long long fA(int n){
        if(n==1) return 6;
        if(dpA[n]!=-1) return dpA[n];
        return dpA[n]=(2 * fA(n - 1) + 2 * fB(n - 1)) % MOD;
  }
  long long fB(int n) {
        if (n == 1) return 6;
        if (dpB[n]!=-1) return dpB[n];
        return dpB[n]=(2 * fA(n - 1) + 3 * fB(n - 1)) % MOD;
    }
  int numOfWays(int n) {
        memset(dpA, -1, sizeof(dpA));
        memset(dpB, -1, sizeof(dpB));
        return (fA(n) + fB(n)) % MOD;
    }
};


Tabulation:

class Solution {
public:
    int numOfWays(int n) {
        int const MOD=1e9+7;
        long long A[n+1],B[n+1];
        A[1]=6;
        B[1]=6;

        for(int i=2;i<=n;i++){
            A[i]=(2*A[i-1]+2*B[i-1])%MOD;
            B[i]=(2*A[i-1]+3*B[i-1])%MOD;
        }
        return (A[n]+B[n])%MOD;
    }
};
